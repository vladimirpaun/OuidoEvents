document.addEventListener('DOMContentLoaded', () => {
    const navLinks = document.querySelectorAll('.crm-nav-link');
    const pages = document.querySelectorAll('.crm-page');
    const storageKey = 'owner-crm-v3-active-page';

    function activatePage(pageId) {
        if (!pageId) {
            return;
        }
        let pageFound = false;
        pages.forEach(page => {
            const isMatch = page.dataset.page === pageId;
            page.classList.toggle('is-active', isMatch);
            if (isMatch) {
                pageFound = true;
                if (pageId !== 'record-detail') {
                    localStorage.setItem(storageKey, pageId);
                }
            }
        });
        navLinks.forEach(link => {
            link.classList.toggle('is-active', link.dataset.pageTarget === pageId);
        });
        if (pageFound) {
            if (window.location.hash !== `#${pageId}`) {
                history.pushState({ page: pageId }, '', `#${pageId}`);
            }
            window.scrollTo(0, 0);
        }
    }

    navLinks.forEach(link => {
        link.addEventListener('click', () => activatePage(link.dataset.pageTarget));
    });

    window.addEventListener('popstate', (event) => {
        const pageId = event.state ? event.state.page : (window.location.hash.replace('#', '') || 'overview');
        activatePage(pageId);
    });

    let storedPage = localStorage.getItem(storageKey);
    if (storedPage === 'record-detail') {
        storedPage = 'overview';
    }
    const initialPage = window.location.hash.replace('#', '') || storedPage || 'overview';
    activatePage(initialPage);

    const today = new Date();
    const addDays = (days) => {
        const d = new Date(today);
        d.setDate(d.getDate() + days);
        return d;
    };
    const monthNames = ['ian', 'feb', 'mar', 'apr', 'mai', 'iun', 'iul', 'aug', 'sep', 'oct', 'noi', 'dec'];
    const formatDate = (date) => `${date.getDate()} ${monthNames[date.getMonth()]} ${date.getFullYear()}`;
    const formatTime = (date) => `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;

    const bookings = [
        {
            id: 1,
            client: 'Andrei Popescu',
            event: 'Nuntă',
            venue: 'Forest Lodge',
            date: formatDate(addDays(8)),
            guests: 120,
            status: 'availability_request',
            email: 'andrei.popescu@email.com',
            phone: '+40 723 123 456',
            details: ''
        },
        {
            id: 2,
            client: 'Studio Creativ',
            event: 'Eveniment Corporate',
            venue: 'Urban Loft',
            date: formatDate(addDays(4)),
            guests: 80,
            status: 'offer_sent',
            autoGenerated: true,
            email: 'office@studiocreativ.ro',
            phone: '+40 721 987 654',
            details: ''
        },
        {
            id: 3,
            client: 'Mihaela & Vlad',
            event: 'Botez',
            venue: 'Casa Miraval',
            date: formatDate(addDays(15)),
            guests: 60,
            status: 'offer_requested',
            email: 'mihaela.vlad@gmail.com',
            phone: '+40 744 555 121',
            details: ''
        },
        {
            id: 4,
            client: 'Tech Horizon',
            event: 'Petrecere Privată',
            venue: 'Hub Creativ',
            date: formatDate(addDays(21)),
            guests: 150,
            status: 'pre_booked',
            email: 'events@techhorizon.com',
            phone: '+44 20 1234 5678',
            details: ''
        },
        {
            id: 5,
            client: 'EMEA Sales Team',
            event: 'Conferință',
            venue: 'Villa Lac',
            date: formatDate(addDays(28)),
            guests: 220,
            status: 'confirmed',
            email: 'sales-emea@company.com',
            phone: '+44 7700 900123',
            details: ''
        },
        {
            id: 6,
            client: 'Digital Nomads',
            event: 'Eveniment Corporate',
            venue: 'Urban Loft',
            date: formatDate(addDays(12)),
            guests: 40,
            status: 'viewing_request',
            email: 'hello@digitalnomads.io',
            phone: '+1 415 555 0198',
            details: ''
        },
        {
            id: 7,
            client: 'Laura & Dan',
            event: 'Cununie Civilă',
            venue: 'Forest Lodge',
            date: formatDate(addDays(45)),
            guests: 50,
            status: 'availability_confirmed',
            email: 'laura.dan@email.com',
            phone: '+40 722 888 321',
            details: ''
        },
        {
            id: 8,
            client: 'Art Gallery',
            event: 'Petrecere Privată',
            venue: 'Hub Creativ',
            date: formatDate(addDays(35)),
            guests: 100,
            status: 'viewing_rescheduled',
            email: 'contact@artgallery.ro',
            phone: '+40 728 654 321',
            details: ''
        },
        {
            id: 9,
            client: 'Familia Ionescu',
            event: 'Cununie Civilă',
            venue: 'Forest Lodge',
            date: formatDate(addDays(60)),
            guests: 30,
            status: 'cancelled',
            email: 'ionescu.family@yahoo.com',
            phone: '+40 726 000 321',
            details: ''
        }
    ];

    const viewings = [
        { id: 1, client: 'Ioana Matei', venue: 'Villa Lac', date: formatDate(addDays(2)), hour: '11:00', status: 'viewing_scheduled', email: 'ioana.matei@gmail.com', phone: '+40 726 456 789', notes: '' },
        { id: 2, client: 'Căsătorim.ro', venue: 'Forest Lodge', date: formatDate(addDays(4)), hour: '09:30', status: 'viewing_request', email: 'contact@casatorim.ro', phone: '+40 723 111 222', notes: '' },
        { id: 3, client: 'Eventify', venue: 'Urban Loft', date: formatDate(addDays(4)), hour: '15:00', status: 'viewing_rescheduled', email: 'hello@eventify.ro', phone: '+40 735 222 111', notes: '' },
        { id: 4, client: 'Alex & Ruxandra', venue: 'Casa Miraval', date: formatDate(addDays(6)), hour: '17:00', status: 'viewing_scheduled', email: 'alexandrux@gmail.com', phone: '+40 725 888 654', notes: '' },
        { id: 5, client: 'Art Expo Team', venue: 'Hub Creativ', date: formatDate(addDays(8)), hour: '10:30', status: 'viewing_request', email: 'team@artexpo.ro', phone: '+40 733 654 987', notes: '' }
    ];

    let selectedBookingId = null;
    let selectedViewingId = null;

    let autoOfferEnabled = true;
    let automationToastTimeout = null;

    const bookingStatusOrder = [
        'availability_request',
        'availability_confirmed',
        'offer_requested',
        'offer_sent',
        'viewing_request',
        'viewing_rescheduled',
        'viewing_scheduled',
        'pre_booked',
        'confirmed',
        'rejected',
        'cancelled'
    ];

    const bookingStatusMeta = {
        availability_request: {
            label: 'Cerere disponibilitate',
            className: 'availability_request',
            color: '#b45309',
            owner: {
                description: 'Venue-ul a primit o cerere de disponibilitate.',
                actions: ['Confirmă disponibilitatea', 'Respinge'],
                nextStep: 'Confirmă disponibilitatea'
            },
            client: {
                label: 'Cerere disponibilitate trimisă',
                description: 'Locația a primit cererea ta și verifică disponibilitatea pentru data selectată.',
                actions: ['Anulează cererea']
            }
        },
        availability_confirmed: {
            label: 'Disponibilitate confirmată',
            className: 'availability_confirmed',
            color: '#2563eb',
            owner: {
                description: 'Data este liberă.',
                actions: ['Așteaptă cererea clientului (ofertă sau vizionare)'],
                nextStep: 'Așteaptă cererea clientului (ofertă sau vizionare)'
            },
            client: {
                label: 'Dată disponibilă – poți cere ofertă',
                description: 'Locația a confirmat că data este liberă.',
                actions: ['Cere ofertă', 'Cere vizionare', 'Anulează cererea']
            }
        },
        offer_requested: {
            label: 'Ofertă solicitată',
            className: 'offer_requested',
            color: '#a855f7',
            owner: {
                description: 'Clientul a cerut o ofertă.',
                actions: ['Trimite ofertă', 'Respinge cererea'],
                nextStep: 'Trimite ofertă'
            },
            client: {
                label: 'Ofertă cerută',
                description: 'Ai solicitat o ofertă personalizată, așteptând răspunsul locației.',
                actions: ['Anulează cererea']
            }
        },
        offer_sent: {
            label: 'Ofertă trimisă',
            className: 'offer_sent',
            color: '#7c3aed',
            owner: {
                description: 'Oferta a fost transmisă clientului.',
                actions: ['Pre-rezervă data (la cererea clientului)', 'Respinge'],
                nextStep: 'Pre-rezervă data (la cererea clientului)'
            },
            client: {
                label: 'Ofertă primită',
                description: 'Locația ți-a trimis o ofertă personalizată.',
                actions: ['Vezi ofertă', 'Pune întrebări', 'Cere vizionare', 'Anulează cererea']
            }
        },
        viewing_request: {
            label: 'Cerere vizionare',
            className: 'viewing_request',
            color: '#0ea5e9',
            owner: {
                description: 'Clientul a cerut o vizionare.',
                actions: ['Confirmă vizionarea', 'Propune altă dată', 'Respinge'],
                nextStep: 'Confirmă vizionarea'
            },
            client: {
                label: 'Cerere vizionare trimisă',
                description: 'Ai cerut o vizionare a locației.',
                actions: ['Anulează vizionarea']
            }
        },
        viewing_rescheduled: {
            label: 'Vizionare reprogramată',
            className: 'viewing_rescheduled',
            color: '#0284c7',
            owner: {
                description: 'O nouă dată de vizionare a fost propusă.',
                actions: ['Confirmă vizionarea', 'Anulează vizionarea'],
                nextStep: 'Confirmă vizionarea'
            },
            client: {
                label: 'Vizionare reprogramată',
                description: 'Locația a propus o altă dată pentru vizionare.',
                actions: ['Acceptă noua dată', 'Refuză vizionarea']
            }
        },
        viewing_scheduled: {
            label: 'Vizionare programată',
            className: 'viewing_scheduled',
            color: '#2563eb',
            owner: {
                description: 'Vizionarea a fost confirmată.',
                actions: ['(după tur) Trimite ofertă actualizată', '(opțional) Pre-rezervă data'],
                nextStep: 'Trimite ofertă actualizată după tur'
            },
            client: {
                label: 'Vizionare confirmată',
                description: 'Vizionarea este programată la o dată și oră stabilite.',
                actions: ['Adaugă în calendar', 'Anulează vizionarea']
            }
        },
        pre_booked: {
            label: 'Pre-rezervat',
            className: 'pre_booked',
            color: '#0d9488',
            owner: {
                description: 'Data este blocată temporar (hold).',
                actions: ['Confirmă rezervarea (după avans)', 'Respinge'],
                nextStep: 'Confirmă rezervarea (după avans)'
            },
            client: {
                label: 'Dată blocată temporar (Pre-rezervat)',
                description: 'Locația a blocat data provizoriu.',
                actions: ['Renunță la rezervare']
            }
        },
        confirmed: {
            label: 'Rezervat',
            className: 'confirmed',
            color: '#15803d',
            owner: {
                description: 'Rezervarea a fost confirmată și avansul încasat.',
                actions: ['Adaugă notă internă', 'Vezi detalii'],
                nextStep: 'Adaugă notă internă'
            },
            client: {
                label: 'Rezervat',
                description: 'Rezervarea a fost confirmată de locație (după avans).',
                actions: ['Lasă feedback după eveniment']
            }
        },
        rejected: {
            label: 'Respins',
            className: 'rejected',
            color: '#b91c1c',
            owner: {
                description: 'Cererea a fost refuzată.',
                actions: ['Vezi detalii', 'Adaugă notă internă'],
                nextStep: 'Vezi detalii'
            },
            client: {
                label: 'Indisponibil / Refuzat',
                description: 'Locația nu este disponibilă sau a refuzat cererea.',
                actions: ['Vezi mesajul locației', 'Trimite o nouă cerere']
            }
        },
        cancelled: {
            label: 'Anulat',
            className: 'cancelled',
            color: '#dc2626',
            owner: {
                description: 'Clientul a anulat cererea.',
                actions: ['Vezi detalii', 'Adaugă notă internă'],
                nextStep: 'Vezi detalii'
            },
            client: {
                label: 'Anulat de client',
                description: 'Ai anulat cererea înainte de confirmare.',
                actions: ['Retrimite cererea']
            }
        }
    };

    const bookingActionLibrary = {
        confirm_availability: {
            key: 'confirm_availability',
            label: 'Confirmă disponibilitatea',
            title: 'Data este liberă. Poți trimite automat oferta dacă ai activată opțiunea din setări.'
        },
        send_offer: {
            key: 'send_offer',
            label: 'Trimite ofertă',
            title: 'Trimite propunerea de preț și pachet către client.'
        },
        send_updated_offer: {
            key: 'send_updated_offer',
            label: 'Trimite ofertă actualizată',
            title: 'Trimite oferta actualizată după vizionare.'
        },
        schedule_viewing: {
            key: 'schedule_viewing',
            label: 'Confirmă vizionarea',
            title: 'Confirmă intervalul de vizionare cu clientul.'
        },
        propose_new_date: {
            key: 'propose_new_date',
            label: 'Propune altă dată',
            title: 'Propune un nou interval pentru vizionare.'
        },
        pre_reserve: {
            key: 'pre_reserve',
            label: 'Pre-rezervă data',
            title: 'Blochează provizoriu data pentru client.'
        },
        mark_confirmed: {
            key: 'mark_confirmed',
            label: 'Confirmă rezervarea',
            title: 'Marchează rezervarea ca fiind confirmată după avans.'
        },
        reject: {
            key: 'reject',
            label: 'Respinge',
            title: 'Respinge această cerere.'
        },
        cancel_viewing: {
            key: 'cancel_viewing',
            label: 'Anulează vizionarea',
            title: 'Anulează vizionarea programată.'
        },
        log_viewing: {
            key: 'log_viewing',
            label: 'Notează după tur',
            title: 'Adaugă notițe interne după vizionare.'
        },
        add_note: {
            key: 'add_note',
            label: 'Adaugă notă internă',
            title: 'Adaugă o notă internă pentru echipă.'
        },
        open_details: {
            key: 'open_details',
            label: 'Vezi detalii',
            title: 'Deschide detaliile rezervării.'
        }
    };

    const bookingActionsByStatus = {
        availability_request: ['confirm_availability', 'reject'],
        availability_confirmed: ['send_offer', 'schedule_viewing', 'open_details'],
        offer_requested: ['send_offer', 'reject'],
        offer_sent: ['pre_reserve', 'reject'],
        viewing_request: ['schedule_viewing', 'propose_new_date', 'reject'],
        viewing_rescheduled: ['schedule_viewing', 'cancel_viewing'],
        viewing_scheduled: ['send_updated_offer', 'pre_reserve'],
        pre_booked: ['mark_confirmed', 'reject'],
        confirmed: ['add_note', 'open_details'],
        rejected: ['open_details', 'add_note'],
        cancelled: ['open_details', 'add_note'],
        default: ['open_details']
    };

    const viewingStatusMeta = {
        viewing_request: {
            label: 'Cerere vizionare primită',
            clientLabel: 'Cerere vizionare trimisă',
            className: 'viewing_request',
            color: '#0ea5e9',
            description: 'Clientul a cerut un tur al locației.'
        },
        viewing_rescheduled: {
            label: 'Vizionare reprogramată',
            clientLabel: 'Vizionare reprogramată',
            className: 'viewing_rescheduled',
            color: '#0284c7',
            description: 'Ai propus sau acceptat o nouă dată pentru vizionare.'
        },
        viewing_scheduled: {
            label: 'Vizionare programată',
            clientLabel: 'Vizionare confirmată',
            className: 'viewing_scheduled',
            color: '#2563eb',
            description: 'Vizionarea este confirmată în calendar.'
        },
        confirmed: {
            label: 'Vizionare confirmată',
            clientLabel: 'Vizionare confirmată',
            className: 'viewing_scheduled',
            color: '#15803d',
            description: 'Ai confirmat participarea la vizionare.'
        }
    };

    const statusCatalog = {
        booking: bookingStatusMeta,
        viewing: viewingStatusMeta
    };

    const venues = [
        {
            name: 'Villa Lac',
            city: 'Snagov',
            status: 'activ',
            capacity: '200 persoane',
            image: 'https://images.unsplash.com/photo-1522708323590-d24dbb6b0267?auto=format&fit=crop&w=900&q=60',
            price: 180,
            menuPdfs: ['villa-lac-meniu-standard-2024.pdf', 'villa-lac-bar-selection.pdf']
        },
        {
            name: 'Forest Lodge',
            city: 'Brașov',
            status: 'activ',
            capacity: '150 persoane',
            image: 'https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=900&q=60',
            price: 145,
            menuPdfs: ['forest-lodge-meniu-de-baza.pdf']
        },
        {
            name: 'Urban Loft',
            city: 'București',
            status: 'activ',
            capacity: '120 persoane',
            image: 'https://images.unsplash.com/photo-1529429617124-aee711a52795?auto=format&fit=crop&w=900&q=60',
            price: 160,
            menuPdfs: ['urban-loft-meniu-urban.pdf', 'urban-loft-drink-list.pdf']
        },
        {
            name: 'Casa Miraval',
            city: 'Cluj-Napoca',
            status: 'în onboarding',
            capacity: '90 persoane',
            image: 'https://images.unsplash.com/photo-1590490359854-dfba19688d97?auto=format&fit=crop&w=900&q=60',
            price: 120,
            menuPdfs: []
        }
    ];

    function getVenueMenuPdfs(venueName) {
        const venue = venues.find(entry => entry.name === venueName);
        if (!venue || !Array.isArray(venue.menuPdfs) || venue.menuPdfs.length === 0) {
            return null;
        }
        return venue.menuPdfs;
    }

    function buildMenuDeliveryMessage(menuPdfs, clientName) {
        if (!menuPdfs || menuPdfs.length === 0) {
            return '';
        }
        const label = menuPdfs.length > 1 ? 'Meniurile PDF' : 'Meniul PDF';
        const fileSummary = menuPdfs.join(', ');
        const recipient = clientName ? `către ${clientName}` : 'către client';
        return `${label} (${fileSummary}) au fost trimise automat ${recipient}.`;
    }

    const monthlyOccupancyData = Array.from({ length: 12 }).map((_, i) => {
        const date = new Date(today.getFullYear(), today.getMonth() + i, 1);
        const month = monthNames[date.getMonth()];
        const year = date.getFullYear().toString().slice(-2);
        return {
            month: `${month.charAt(0).toUpperCase() + month.slice(1)} '${year}`,
            occupancy: Math.floor(Math.random() * 71) + 20
        };
    });

    const eventTypeDistributionData = [
        { type: 'Nuntă', count: 45, color: '#8b5cf6' },
        { type: 'Eveniment Corporate', count: 25, color: '#22c55e' },
        { type: 'Botez', count: 18, color: '#f59e0b' },
        { type: 'Petrecere Privată', count: 12, color: '#f43f5e' }
    ];

    function populateSelect(selectEl, options, includeAll = true, allText = 'Toate locațiile') {
        if (!selectEl) {
            return;
        }
        selectEl.innerHTML = '';
        if (includeAll) {
            const opt = document.createElement('option');
            opt.value = 'all';
            opt.textContent = allText;
            selectEl.appendChild(opt);
        }
        options.forEach(option => {
            const opt = document.createElement('option');
            opt.value = option;
            opt.textContent = option;
            selectEl.appendChild(opt);
        });
    }

    const venuesSelect = new Set(bookings.map(item => item.venue));
    viewings.forEach(item => venuesSelect.add(item.venue));

    populateSelect(document.getElementById('bookings-venue-filter'), Array.from(venuesSelect).sort(), true, 'Toate locațiile');
    populateSelect(document.getElementById('viewings-venue-filter'), Array.from(venuesSelect).sort());
    populateSelect(document.getElementById('viewings-calendar-venue-filter'), Array.from(venuesSelect).sort(), true);
    populateSelect(document.getElementById('availability-venue-filter'), Array.from(venuesSelect).sort(), true);
    document.getElementById('availability-venue-filter')?.addEventListener('change', renderMonthlyCalendar);

    const bookingStatusFilter = document.getElementById('bookings-status-filter');
    if (bookingStatusFilter) {
        populateSelect(bookingStatusFilter, bookingStatusOrder, true, 'Toate statusurile');
        Array.from(bookingStatusFilter.options).forEach(option => {
            if (option.value !== 'all') {
                option.textContent = bookingStatusMeta[option.value]?.label || option.value;
            }
        });
    }

    function hexToRgba(hex, alpha = 1) {
        if (typeof hex !== 'string') {
            return null;
        }
        const normalized = hex.replace('#', '');
        if (![3, 6].includes(normalized.length)) {
            return null;
        }
        const full = normalized.length === 3 ? normalized.split('').map(char => char + char).join('') : normalized;
        const bigint = parseInt(full, 16);
        if (Number.isNaN(bigint)) {
            return null;
        }
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function createStatusChip(status, category = 'booking') {
        const catalogue = statusCatalog[category] || {};
        const meta = catalogue[status];
        const span = document.createElement('span');
        span.className = 'status-chip';
        const className = meta?.className || (typeof status === 'string' ? status : 'necunoscut');
        span.dataset.status = className;
        span.textContent = meta?.label || status || 'Necunoscut';
        if (meta?.color) {
            const backgroundColor = hexToRgba(meta.color, 0.18);
            if (backgroundColor) {
                span.style.backgroundColor = backgroundColor;
            }
            span.style.color = meta.color;
        }
        return span;
    }

    function showAutomationToast(message) {
        const toast = document.getElementById('automation-toast');
        if (!toast) {
            return;
        }
        toast.textContent = message;
        toast.classList.add('is-visible');
        if (automationToastTimeout) {
            clearTimeout(automationToastTimeout);
        }
        automationToastTimeout = setTimeout(() => {
            toast.classList.remove('is-visible');
            automationToastTimeout = null;
        }, 5000);
    }

    function hideAutomationToast() {
        const toast = document.getElementById('automation-toast');
        if (!toast) {
            return;
        }
        toast.classList.remove('is-visible');
        if (automationToastTimeout) {
            clearTimeout(automationToastTimeout);
            automationToastTimeout = null;
        }
    }

    function highlightBookingRow(bookingId, { scroll = false } = {}) {
        const tableBody = document.getElementById('bookings-table-body');
        if (!tableBody) {
            return null;
        }
        tableBody.querySelectorAll('.is-highlighted').forEach(row => row.classList.remove('is-highlighted'));
        const targetRow = tableBody.querySelector(`tr[data-identifier="${bookingId}"]`);
        if (targetRow) {
            targetRow.classList.add('is-highlighted');
            if (scroll) {
                targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        return targetRow;
    }

    function highlightViewingRow(viewingId, { scroll = false } = {}) {
        const tableBody = document.getElementById('viewings-table-body');
        if (!tableBody) {
            return null;
        }
        tableBody.querySelectorAll('.is-highlighted').forEach(row => row.classList.remove('is-highlighted'));
        const targetRow = tableBody.querySelector(`tr[data-identifier="${viewingId}"]`);
        if (targetRow) {
            targetRow.classList.add('is-highlighted');
            if (scroll) {
                targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
        return targetRow;
    }

    function createRecordInfoItem(label, value, { meta, isMissing } = {}) {
        const itemEl = document.createElement('div');
        itemEl.className = 'booking-row-item';

        const labelEl = document.createElement('span');
        labelEl.className = 'booking-row-label';
        labelEl.textContent = label;

        const valueEl = document.createElement('span');
        valueEl.className = 'booking-row-value';
        valueEl.textContent = value || '—';
        if (isMissing) {
            valueEl.classList.add('is-missing-value');
        }

        itemEl.append(labelEl, valueEl);

        if (meta) {
            const metaEl = document.createElement('span');
            metaEl.className = 'booking-row-meta';
            metaEl.textContent = meta;
            itemEl.appendChild(metaEl);
        }

        return itemEl;
    }

    const recordDetailFields = {
        client: document.querySelector('[data-detail-field="client"]'),
        status: document.querySelector('[data-detail-field="status"]'),
        email: document.querySelector('[data-detail-field="email"]'),
        phone: document.querySelector('[data-detail-field="phone"]'),
        event: document.querySelector('[data-detail-field="event"]'),
        guests: document.querySelector('[data-detail-field="guests"]'),
        venue: document.querySelector('[data-detail-field="venue"]'),
        date: document.querySelector('[data-detail-field="date"]'),
        time: document.querySelector('[data-detail-field="time"]')
    };
    const recordDetailTimeWrapper = document.querySelector('[data-detail-time-wrapper]');
    const recordDetailHeading = document.getElementById('record-detail-heading');
    const recordDetailSubtitle = document.getElementById('record-detail-subtitle');
    const recordDetailNoteInput = document.getElementById('record-detail-note');
    const recordDetailBackBtn = document.getElementById('record-detail-back');
    const recordDetailSaveBtn = document.getElementById('record-detail-save');
    const recordDetailState = {
        type: null,
        id: null,
        sourcePage: 'bookings'
    };

    function populateDetailField(field, value, fallback = '—') {
        const target = recordDetailFields[field];
        if (target) {
            target.textContent = value || fallback;
        }
    }

    function showRecordDetailPage(type, record, sourcePage = 'bookings') {
        if (!record) {
            return;
        }
        recordDetailState.type = type;
        recordDetailState.id = record.id;
        recordDetailState.sourcePage = sourcePage;
        if (type === 'viewing') {
            selectedViewingId = record.id;
        } else {
            selectedBookingId = record.id;
        }

        if (recordDetailHeading) {
            recordDetailHeading.textContent = type === 'viewing' ? 'Detalii vizionare' : 'Detalii rezervare';
        }
        if (recordDetailSubtitle) {
            recordDetailSubtitle.textContent = type === 'viewing'
                ? 'Confirmă informațiile despre vizionare și notează următorii pași pentru echipă.'
                : 'Revizuiește detaliile cererii și ține evidența discuțiilor interne.';
        }

        populateDetailField('client', record.client || '—');
        const statusMeta = type === 'viewing' ? viewingStatusMeta[record.status] : bookingStatusMeta[record.status];
        populateDetailField('status', statusMeta?.label || record.status || '—');
        populateDetailField('email', record.email || 'Nu a fost furnizat');
        populateDetailField('phone', record.phone || 'Nu a fost furnizat');
        populateDetailField('event', record.event || '—');
        populateDetailField('venue', record.venue || '—');
        populateDetailField('date', record.date || '—');

        const guestsField = recordDetailFields.guests;
        if (guestsField) {
            const hasGuests = Number.isFinite(record.guests) && record.guests > 0;
            if (type === 'viewing') {
                guestsField.textContent = hasGuests ? `${record.guests} invitați` : '—';
                guestsField.classList.remove('is-missing-value');
            } else {
                guestsField.textContent = hasGuests ? `${record.guests} invitați` : 'Necesită completare';
                guestsField.classList.toggle('is-missing-value', !hasGuests);
            }
        }

        if (recordDetailTimeWrapper) {
            recordDetailTimeWrapper.hidden = type !== 'viewing';
        }
        if (type === 'viewing') {
            populateDetailField('time', record.hour || 'Nu este stabilită');
        } else {
            populateDetailField('time', '—');
        }

        if (recordDetailNoteInput) {
            const noteValue = type === 'viewing' ? record.notes : record.details;
            recordDetailNoteInput.value = noteValue || '';
        }

        activatePage('record-detail');
    }

    function returnToListPage({ scroll = false } = {}) {
        const targetPage = recordDetailState.sourcePage || (recordDetailState.type === 'viewing' ? 'viewings' : 'bookings');
        const recordId = recordDetailState.id;
        activatePage(targetPage);
        if (!recordId) {
            return;
        }
        requestAnimationFrame(() => {
            if (recordDetailState.type === 'viewing') {
                highlightViewingRow(recordId, { scroll });
            } else {
                highlightBookingRow(recordId, { scroll });
            }
        });
    }

    function saveRecordDetailNote() {
        if (!recordDetailNoteInput) {
            return;
        }
        const { type, id } = recordDetailState;
        if (!type || !id) {
            showAutomationToast('Selectează o înregistrare înainte de a salva nota.');
            return;
        }
        const noteValue = recordDetailNoteInput.value.trim();
        if (type === 'viewing') {
            const viewing = viewings.find(item => item.id === id);
            if (!viewing) {
                return;
            }
            viewing.notes = noteValue;
            renderViewingsTable();
            renderViewingsCalendar();
            renderViewingsStatusChart();
            renderOverviewLists();
            highlightViewingRow(id);
            showAutomationToast('Nota internă a vizionării a fost salvată.');
        } else {
            const booking = bookings.find(item => item.id === id);
            if (!booking) {
                return;
            }
            booking.details = noteValue;
            renderBookingsTable();
            renderOverviewLists();
            renderMonthlyCalendar();
            highlightBookingRow(id);
            showAutomationToast('Nota internă a rezervării a fost salvată.');
        }
    }

    function renderOverviewLists() {
        const bookingsList = document.getElementById('overview-bookings-list');
        const eventsList = document.getElementById('overview-events-list');
        const viewingsList = document.getElementById('overview-viewings-list');

        const sortByDateAsc = (collection, dateKey = 'date') => collection.slice().sort((a, b) => {
            const dateA = parseBookingDate(a[dateKey]);
            const dateB = parseBookingDate(b[dateKey]);
            const timeA = dateA ? dateA.getTime() : Number.MAX_SAFE_INTEGER;
            const timeB = dateB ? dateB.getTime() : Number.MAX_SAFE_INTEGER;
            return timeA - timeB;
        });

        if (bookingsList) {
            bookingsList.innerHTML = '';
            const activeBookings = sortByDateAsc(bookings)
                .filter(item => !['cancelled', 'rejected'].includes(item.status))
                .slice(0, 3);

            activeBookings.forEach(item => {
                const row = document.createElement('div');
                row.className = 'list-item';
                const left = document.createElement('div');
                left.innerHTML = `<strong>${item.client}</strong> <span>${item.venue}</span>`;
                const chip = createStatusChip(item.status);
                row.append(left, chip);
                row.addEventListener('click', () => navigateToBooking(item.id));
                bookingsList.appendChild(row);
            });
        }

        if (eventsList) {
            eventsList.innerHTML = '';
            const upcomingConfirmed = sortByDateAsc(bookings)
                .filter(item => ['confirmed', 'pre_booked'].includes(item.status))
                .slice(0, 3);

            upcomingConfirmed.forEach(item => {
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
                const detailsDiv = document.createElement('div');
                detailsDiv.innerHTML = `<strong>${item.event}</strong> <span>${item.venue} · ${item.date}</span>`;
                listItem.addEventListener('click', () => navigateToBooking(item.id));
                listItem.append(detailsDiv);
                eventsList.appendChild(listItem);
            });
        }

        if (viewingsList) {
            viewingsList.innerHTML = '';
            const upcomingViewings = sortByDateAsc(viewings)
                .slice(0, 3);

            upcomingViewings.forEach(item => {
                const listItem = document.createElement('div');
                listItem.className = 'list-item';
                const detailsDiv = document.createElement('div');
                detailsDiv.innerHTML = `<strong>${item.client}</strong> <span>${item.venue} · ${item.date}</span>`;
                const chip = createStatusChip(item.status, 'viewing');
                listItem.addEventListener('click', () => navigateToViewing(item.id));
                listItem.append(detailsDiv, chip);
                viewingsList.appendChild(listItem);
            });
        }
    }

    function renderBookingsTable() {
        const body = document.getElementById('bookings-table-body');
        if (!body) {
            return;
        }
        const venueFilter = document.getElementById('bookings-venue-filter');
        const statusFilter = document.getElementById('bookings-status-filter');
        const clientFilter = document.getElementById('bookings-client-filter');
        const venueValue = venueFilter ? venueFilter.value : 'all';
        const statusValue = statusFilter ? statusFilter.value : 'all';
        body.innerHTML = '';

        const clientQuery = clientFilter ? clientFilter.value.trim().toLowerCase() : '';

        const filteredBookings = bookings
            .filter(item => venueValue === 'all' || item.venue === venueValue)
            .filter(item => statusValue === 'all' || item.status === statusValue)
            .filter(item => {
                if (!clientQuery) {
                    return true;
                }
                return item.client.toLowerCase().includes(clientQuery);
            })
            .slice()
            .sort((a, b) => {
                const dateA = parseBookingDate(a.date);
                const dateB = parseBookingDate(b.date);
                const timeA = dateA ? dateA.getTime() : Number.MAX_SAFE_INTEGER;
                const timeB = dateB ? dateB.getTime() : Number.MAX_SAFE_INTEGER;
                return timeA - timeB;
            });

        filteredBookings.forEach(item => {
            const row = body.insertRow();
            row.dataset.identifier = String(item.id);
            if (selectedBookingId === item.id) {
                row.classList.add('is-highlighted');
            }

            const cell = row.insertCell();

            const wrapper = document.createElement('div');
            wrapper.className = 'booking-row';

            const topRow = document.createElement('div');
            topRow.className = 'booking-row-top';

            topRow.appendChild(createRecordInfoItem('Client', item.client));
            topRow.appendChild(createRecordInfoItem('Eveniment', item.event, {
                meta: item.venue ? `Locație: ${item.venue}` : null
            }));
            topRow.appendChild(createRecordInfoItem('Dată', item.date));

            const hasGuests = Number.isFinite(item.guests) && item.guests > 0;
            topRow.appendChild(createRecordInfoItem('Invitați', hasGuests ? `${item.guests} invitați` : 'Necesită completare', {
                isMissing: !hasGuests
            }));

            wrapper.appendChild(topRow);

            const statusMeta = bookingStatusMeta[item.status];
            const bottomRow = document.createElement('div');
            bottomRow.className = 'booking-row-bottom';

            const statusContainer = document.createElement('div');
            statusContainer.className = 'booking-row-status';
            statusContainer.appendChild(createStatusChip(item.status));
            if (item.autoGenerated && item.status === 'offer_sent') {
                const autoBadge = document.createElement('span');
                autoBadge.className = 'status-secondary';
                autoBadge.textContent = 'Ofertă trimisă automat după confirmare';
                statusContainer.appendChild(autoBadge);
            }

            const ownerMeta = statusMeta?.owner;
            const nextStep = document.createElement('span');
            nextStep.className = 'booking-row-next-step';
            nextStep.textContent = `Pas următor: ${ownerMeta?.nextStep || '—'}`;
            statusContainer.appendChild(nextStep);

            bottomRow.appendChild(statusContainer);

            const actionsWrapper = document.createElement('div');
            actionsWrapper.className = 'table-actions booking-row-actions';
            const actionKeys = bookingActionsByStatus[item.status] || bookingActionsByStatus.default;
            actionKeys.forEach(actionKey => {
                const definition = bookingActionLibrary[actionKey];
                if (!definition) {
                    return;
                }
                const button = document.createElement('button');
                button.type = 'button';
                button.dataset.action = definition.key;
                button.title = definition.title || definition.label;
                button.textContent = definition.label;
                actionsWrapper.appendChild(button);
            });
            if (actionsWrapper.children.length) {
                bottomRow.appendChild(actionsWrapper);
            }

            wrapper.appendChild(bottomRow);
            cell.appendChild(wrapper);

            row.addEventListener('click', (event) => {
                if (event.target.closest('button')) {
                    return;
                }
                selectedBookingId = item.id;
                showRecordDetailPage('booking', item, 'bookings');
            });
        });
    }

    function renderViewingsTable() {
        const body = document.getElementById('viewings-table-body');
        if (!body) {
            return;
        }
        const venueFilter = document.getElementById('viewings-venue-filter');
        const venueValue = venueFilter ? venueFilter.value : 'all';
        body.innerHTML = '';

        viewings
            .filter(item => venueValue === 'all' || item.venue === venueValue)
            .slice()
            .sort((a, b) => {
                const dateA = parseBookingDate(a.date);
                const dateB = parseBookingDate(b.date);
                const timeA = dateA ? dateA.getTime() : Number.MAX_SAFE_INTEGER;
                const timeB = dateB ? dateB.getTime() : Number.MAX_SAFE_INTEGER;
                return timeA - timeB;
            })
            .forEach(item => {
                const row = body.insertRow();
                row.dataset.identifier = String(item.id);
                if (selectedViewingId === item.id) {
                    row.classList.add('is-highlighted');
                }

                const cell = row.insertCell();

                const wrapper = document.createElement('div');
                wrapper.className = 'booking-row viewing-row';

                const topRow = document.createElement('div');
                topRow.className = 'booking-row-top';
                topRow.appendChild(createRecordInfoItem('Client', item.client));
                topRow.appendChild(createRecordInfoItem('Locație', item.venue));
                topRow.appendChild(createRecordInfoItem('Dată', item.date));
                topRow.appendChild(createRecordInfoItem('Ora', item.hour || '—'));

                wrapper.appendChild(topRow);

                const bottomRow = document.createElement('div');
                bottomRow.className = 'booking-row-bottom';

                const statusContainer = document.createElement('div');
                statusContainer.className = 'booking-row-status';
                statusContainer.appendChild(createStatusChip(item.status, 'viewing'));

                const viewingMeta = viewingStatusMeta[item.status];
                if (viewingMeta?.description) {
                    const description = document.createElement('span');
                    description.className = 'booking-row-next-step';
                    description.textContent = viewingMeta.description;
                    statusContainer.appendChild(description);
                }

                bottomRow.appendChild(statusContainer);

                const actions = document.createElement('div');
                actions.className = 'table-actions booking-row-actions';
                const confirmBtn = document.createElement('button');
                confirmBtn.type = 'button';
                confirmBtn.dataset.action = 'confirm';
                confirmBtn.textContent = 'Confirmă prezența';
                const rescheduleBtn = document.createElement('button');
                rescheduleBtn.type = 'button';
                rescheduleBtn.dataset.action = 'reschedule';
                rescheduleBtn.textContent = 'Reprogramează';
                actions.append(confirmBtn, rescheduleBtn);
                if (actions.children.length) {
                    bottomRow.appendChild(actions);
                }

                wrapper.appendChild(bottomRow);
                cell.appendChild(wrapper);

                row.addEventListener('click', (event) => {
                    if (event.target.closest('button')) {
                        return;
                    }
                    selectedViewingId = item.id;
                    showRecordDetailPage('viewing', item, 'viewings');
                });
            });
    }

    const monthMap = { 'ian': 0, 'feb': 1, 'mar': 2, 'apr': 3, 'mai': 4, 'iun': 5, 'iul': 6, 'aug': 7, 'sep': 8, 'oct': 9, 'noi': 10, 'dec': 11 };

    function parseBookingDate(dateString) {
        const parts = dateString.split(' ');
        if (parts.length < 3) {
            return null;
        }
        const day = parseInt(parts[0], 10);
        const month = monthMap[parts[1].toLowerCase()];
        const year = parseInt(parts[2], 10);
        if (Number.isNaN(day) || month === undefined || Number.isNaN(year)) {
            return null;
        }
        return new Date(year, month, day);
    }

    let currentMonthOffset = 0;

    function renderMonthlyCalendar() {
        const grid = document.getElementById('availability-calendar-grid');
        const monthYearEl = document.getElementById('availability-month-year');
        const venueFilter = document.getElementById('availability-venue-filter');
        if (!grid || !monthYearEl || !venueFilter) {
            return;
        }
        grid.innerHTML = '';
        const currentDate = new Date();
        currentDate.setDate(1);
        currentDate.setMonth(currentDate.getMonth() + currentMonthOffset);
        const selectedVenue = venueFilter.value;
        const month = currentDate.getMonth();
        const year = currentDate.getFullYear();
        const monthName = currentDate.toLocaleString('ro-RO', { month: 'long' });
        monthYearEl.textContent = `${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${year}`;

        const dayNames = ['Luni', 'Marți', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă', 'Duminică'];
        dayNames.forEach(dayName => {
            const dayHeader = document.createElement('div');
            dayHeader.className = 'calendar-day-header';
            dayHeader.textContent = dayName;
            grid.appendChild(dayHeader);
        });

        const firstDayOfMonth = new Date(year, month, 1);
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const startDayOfWeek = (firstDayOfMonth.getDay() + 6) % 7;
        for (let i = 0; i < startDayOfWeek; i += 1) {
            const emptyCell = document.createElement('div');
            emptyCell.className = 'calendar-day is-other-month';
            grid.appendChild(emptyCell);
        }

        const todayNormalized = new Date();
        todayNormalized.setHours(0, 0, 0, 0);

        for (let day = 1; day <= daysInMonth; day += 1) {
            const dayCell = document.createElement('div');
            dayCell.className = 'calendar-day';
            const thisDate = new Date(year, month, day);
            if (thisDate.getTime() === todayNormalized.getTime()) {
                dayCell.classList.add('is-today');
            }
            dayCell.innerHTML = `<span class="day-number">${day}</span>`;

            const eventsForDay = bookings.filter(booking => {
                if (!['confirmed', 'pre_booked'].includes(booking.status)) {
                    return false;
                }
                if (selectedVenue !== 'all' && booking.venue !== selectedVenue) {
                    return false;
                }
                const bookingDate = parseBookingDate(booking.date);
                return bookingDate &&
                    bookingDate.getFullYear() === year &&
                    bookingDate.getMonth() === month &&
                    bookingDate.getDate() === day;
            });

            eventsForDay.forEach(event => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'calendar-event';
                const calendarStatus = event.status === 'confirmed' ? 'booked' : 'pre_booked';
                eventDiv.dataset.status = calendarStatus;
                eventDiv.textContent = selectedVenue === 'all' ? `${event.event} - ${event.venue}` : event.event;
                eventDiv.title = `Click pentru a vedea detaliile booking-ului pentru "${event.client}"`;
                eventDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    navigateToBooking(event.id);
                });
                dayCell.appendChild(eventDiv);
            });

            grid.appendChild(dayCell);
        }
    }

    let currentViewingsMonthOffset = 0;

    function renderViewingsCalendar() {
        const grid = document.getElementById('viewings-calendar-grid');
        const monthYearEl = document.getElementById('viewings-month-year');
        const venueFilter = document.getElementById('viewings-calendar-venue-filter');
        if (!grid || !monthYearEl || !venueFilter) {
            return;
        }
        grid.innerHTML = '';
        const baseDate = new Date();
        baseDate.setDate(1);
        baseDate.setMonth(baseDate.getMonth() + currentViewingsMonthOffset);
        const selectedVenue = venueFilter.value;
        const month = baseDate.getMonth();
        const year = baseDate.getFullYear();
        const monthName = baseDate.toLocaleString('ro-RO', { month: 'long' });
        monthYearEl.textContent = `${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${year}`;

        const dayNames = ['Luni', 'Marți', 'Miercuri', 'Joi', 'Vineri', 'Sâmbătă', 'Duminică'];
        dayNames.forEach(dayName => {
            const dayHeader = document.createElement('div');
            dayHeader.className = 'calendar-day-header';
            dayHeader.textContent = dayName;
            grid.appendChild(dayHeader);
        });

        const firstDayOfMonth = new Date(year, month, 1);
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const startDayOfWeek = (firstDayOfMonth.getDay() + 6) % 7;
        for (let i = 0; i < startDayOfWeek; i += 1) {
            const emptyCell = document.createElement('div');
            emptyCell.className = 'calendar-day is-other-month';
            grid.appendChild(emptyCell);
        }

        const todayNormalized = new Date();
        todayNormalized.setHours(0, 0, 0, 0);

        for (let day = 1; day <= daysInMonth; day += 1) {
            const dayCell = document.createElement('div');
            dayCell.className = 'calendar-day';
            const thisDate = new Date(year, month, day);
            if (thisDate.getTime() === todayNormalized.getTime()) {
                dayCell.classList.add('is-today');
            }
            dayCell.innerHTML = `<span class="day-number">${day}</span>`;

            const viewingsForDay = viewings.filter(viewing => {
                if (selectedVenue !== 'all' && viewing.venue !== selectedVenue) {
                    return false;
                }
                const viewingDate = parseBookingDate(viewing.date);
                return viewingDate &&
                    viewingDate.getFullYear() === year &&
                    viewingDate.getMonth() === month &&
                    viewingDate.getDate() === day;
            });

            viewingsForDay.forEach(viewing => {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'calendar-event';
                const statusMeta = viewingStatusMeta[viewing.status];
                const baseColor = statusMeta?.color || '#2563eb';
                const backgroundColor = typeof hexToRgba === 'function' ? hexToRgba(baseColor, 0.18) : null;
                if (backgroundColor) {
                    eventDiv.style.backgroundColor = backgroundColor;
                } else {
                    eventDiv.style.backgroundColor = 'rgba(37, 99, 235, 0.18)';
                }
                eventDiv.style.color = baseColor;
                eventDiv.dataset.status = viewing.status;
                eventDiv.textContent = `${viewing.client} - ${viewing.hour}`;
                eventDiv.title = `Click pentru a vedea detalii pentru ${viewing.client}`;
                eventDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    navigateToViewing(viewing.id);
                });
                dayCell.appendChild(eventDiv);
            });

            grid.appendChild(dayCell);
        }
    }

    function ensureViewingEntry(booking, { rescheduled = false } = {}) {
        const targetStatus = rescheduled ? 'viewing_rescheduled' : 'viewing_scheduled';
        const existing = viewings.find(viewing => viewing.client === booking.client);
        const parsedDate = parseBookingDate(booking.date) || addDays(3);
        const formattedDate = formatDate(parsedDate);
        if (existing) {
            existing.status = targetStatus;
            existing.date = formattedDate;
            existing.venue = booking.venue;
            existing.email = booking.email || existing.email || '';
            existing.phone = booking.phone || existing.phone || '';
            if (!existing.notes && booking.details) {
                existing.notes = booking.details;
            }
        } else {
            const nextId = viewings.reduce((max, viewing) => Math.max(max, viewing.id || 0), 0) + 1;
            viewings.push({
                id: nextId,
                client: booking.client,
                venue: booking.venue,
                date: formattedDate,
                hour: '12:00',
                status: targetStatus,
                email: booking.email || '',
                phone: booking.phone || '',
                notes: booking.details || ''
            });
        }
        renderViewingsTable();
        renderViewingsCalendar();
        renderViewingsStatusChart();
    }

    function handleBookingAction(bookingId, actionKey) {
        const booking = bookings.find(item => item.id === bookingId);
        if (!booking || !actionKey) {
            return;
        }
        hideAutomationToast();

        switch (actionKey) {
            case 'confirm_availability':
                {
                    const menuPdfs = getVenueMenuPdfs(booking.venue);
                    const menuMessage = buildMenuDeliveryMessage(menuPdfs, booking.client);
                    let toastMessage = '';

                    if (autoOfferEnabled) {
                        booking.status = 'offer_sent';
                        booking.autoGenerated = true;
                        toastMessage = `Locația ${booking.venue} a trimis automat oferta pentru ${booking.date}. Clientul vede „Ofertă primită”.`;
                    } else {
                        booking.status = 'availability_confirmed';
                        booking.autoGenerated = false;
                        toastMessage = `Disponibilitatea a fost confirmată pentru ${booking.date} la ${booking.venue}.`;
                    }

                    if (menuMessage) {
                        toastMessage = toastMessage ? `${toastMessage} ${menuMessage}` : menuMessage;
                    }

                    if (toastMessage) {
                        showAutomationToast(toastMessage);
                    }
                }
                break;
            case 'send_offer':
            case 'send_updated_offer':
                booking.status = 'offer_sent';
                booking.autoGenerated = false;
                break;
            case 'schedule_viewing':
                booking.status = 'viewing_scheduled';
                booking.autoGenerated = false;
                ensureViewingEntry(booking);
                break;
            case 'propose_new_date':
                booking.status = 'viewing_rescheduled';
                booking.autoGenerated = false;
                ensureViewingEntry(booking, { rescheduled: true });
                break;
            case 'cancel_viewing':
                booking.status = 'cancelled';
                booking.autoGenerated = false;
                break;
            case 'pre_reserve':
                booking.status = 'pre_booked';
                booking.autoGenerated = false;
                break;
            case 'mark_confirmed':
                booking.status = 'confirmed';
                booking.autoGenerated = false;
                break;
            case 'reject':
                booking.status = 'rejected';
                booking.autoGenerated = false;
                break;
            case 'add_note':
                showRecordDetailPage('booking', booking, 'bookings');
                if (recordDetailNoteInput) {
                    requestAnimationFrame(() => {
                        recordDetailNoteInput.focus();
                        const noteLength = recordDetailNoteInput.value.length;
                        recordDetailNoteInput.setSelectionRange(noteLength, noteLength);
                    });
                }
                return;
            case 'open_details':
                showRecordDetailPage('booking', booking, 'bookings');
                return;
            case 'log_viewing':
                window.alert('Notează feedback-ul după tur – funcționalitate în dezvoltare.');
                break;
            default:
                console.info('Acțiune neacoperită:', actionKey);
                break;
        }

        renderBookingsTable();
        renderOverviewLists();
        renderMonthlyCalendar();
        highlightBookingRow(booking.id);
    }

    function renderMonthlyOccupancyChart() {
        const container = document.getElementById('monthly-occupancy-chart');
        if (!container) {
            return;
        }
        container.innerHTML = '';
        const svgNs = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNs, 'svg');
        const width = container.clientWidth || 900;
        const height = Math.max(container.clientHeight || 320, 280);
        const padding = { top: 24, right: 28, bottom: 48, left: 48 };
        const chartWidth = width - padding.left - padding.right;
        const chartHeight = height - padding.top - padding.bottom;

        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.maxWidth = 'none';

        const yAxis = document.createElementNS(svgNs, 'g');
        [0, 25, 50, 75, 100].forEach(tick => {
            const y = padding.top + chartHeight - (tick / 100) * chartHeight;
            const line = document.createElementNS(svgNs, 'line');
            line.setAttribute('x1', padding.left);
            line.setAttribute('y1', y);
            line.setAttribute('x2', width - padding.right);
            line.setAttribute('y2', y);
            line.setAttribute('stroke', '#e5eaf1');
            line.setAttribute('stroke-dasharray', '3,3');
            yAxis.appendChild(line);
            const text = document.createElementNS(svgNs, 'text');
            text.setAttribute('x', padding.left - 10);
            text.setAttribute('y', y + 4);
            text.setAttribute('text-anchor', 'end');
            text.setAttribute('font-size', '10');
            text.setAttribute('fill', '#7a7f87');
            text.textContent = `${tick}%`;
            yAxis.appendChild(text);
        });
        svg.appendChild(yAxis);

        const points = monthlyOccupancyData.map((item, index) => {
            const x = padding.left + index * (chartWidth / Math.max(monthlyOccupancyData.length - 1, 1));
            const y = padding.top + chartHeight - (item.occupancy / 100) * chartHeight;
            return { x, y, data: item };
        });

        points.forEach(point => {
            const text = document.createElementNS(svgNs, 'text');
            text.setAttribute('x', point.x);
            text.setAttribute('y', height - padding.bottom + 15);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('font-size', '10');
            text.setAttribute('fill', '#7a7f87');
            text.textContent = point.data.month;
            svg.appendChild(text);
        });

        const pathData = points.map((p, index) => `${index === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
        const linePath = document.createElementNS(svgNs, 'path');
        linePath.setAttribute('d', pathData);
        linePath.setAttribute('fill', 'none');
        linePath.setAttribute('stroke', '#4364F7');
        linePath.setAttribute('stroke-width', '2');
        svg.appendChild(linePath);

        const areaPath = document.createElementNS(svgNs, 'path');
        areaPath.setAttribute('d', `${pathData} L ${points[points.length - 1].x} ${padding.top + chartHeight} L ${points[0].x} ${padding.top + chartHeight} Z`);
        areaPath.setAttribute('fill', 'rgba(67, 100, 247, 0.15)');
        svg.appendChild(areaPath);

        points.forEach(point => {
            const circle = document.createElementNS(svgNs, 'circle');
            circle.setAttribute('cx', point.x);
            circle.setAttribute('cy', point.y);
            circle.setAttribute('r', '4');
            circle.setAttribute('fill', '#4364F7');
            svg.appendChild(circle);
        });

        container.appendChild(svg);
    }

    function renderEventTypeDistributionChart() {
        const container = document.getElementById('event-type-distribution-chart');
        if (!container) {
            return;
        }
        container.innerHTML = '';
        const chartContainer = document.createElement('div');
        chartContainer.className = 'pie-chart-container';
        const svgNs = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNs, 'svg');
        svg.setAttribute('viewBox', '0 0 36 36');
        svg.classList.add('pie-chart-svg');
        const legendContainer = document.createElement('div');
        legendContainer.className = 'pie-chart-legend';
        const total = eventTypeDistributionData.reduce((sum, item) => sum + item.count, 0);
        let accumulatedPercentage = 0;
        eventTypeDistributionData.forEach(item => {
            const percentage = (item.count / total) * 100;
            const slice = document.createElementNS(svgNs, 'circle');
            slice.classList.add('pie-slice');
            slice.setAttribute('cx', '18');
            slice.setAttribute('cy', '18');
            slice.setAttribute('r', '15.9154943092');
            slice.setAttribute('fill', 'transparent');
            slice.setAttribute('stroke', item.color);
            slice.setAttribute('stroke-width', '3.8');
            slice.setAttribute('stroke-dasharray', `${percentage} ${100 - percentage}`);
            slice.setAttribute('stroke-dashoffset', `-${accumulatedPercentage}`);
            const title = document.createElementNS(svgNs, 'title');
            title.textContent = `${item.type}: ${item.count} (${percentage.toFixed(1)}%)`;
            slice.appendChild(title);
            svg.appendChild(slice);

            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            const dot = document.createElement('div');
            dot.className = 'legend-dot';
            dot.style.backgroundColor = item.color;
            const label = document.createElement('span');
            label.textContent = `${item.type} (${item.count})`;
            legendItem.append(dot, label);
            legendContainer.appendChild(legendItem);

            legendItem.addEventListener('mouseenter', () => slice.style.transform = 'scale(1.05)');
            legendItem.addEventListener('mouseleave', () => slice.style.transform = 'scale(1)');
            slice.addEventListener('mouseenter', () => legendItem.style.fontWeight = '600');
            slice.addEventListener('mouseleave', () => legendItem.style.fontWeight = 'normal');

            accumulatedPercentage += percentage;
        });
        chartContainer.appendChild(svg);
        chartContainer.appendChild(legendContainer);
        container.appendChild(chartContainer);
    }

    function renderViewingsStatusChart() {
        const container = document.getElementById('viewings-status-chart');
        if (!container) {
            return;
        }
        const now = new Date();
        const sevenDaysFromNow = new Date();
        sevenDaysFromNow.setDate(now.getDate() + 8);
        now.setHours(0, 0, 0, 0);
        const viewingsInNext7Days = viewings.filter(viewing => {
            const viewingDate = parseBookingDate(viewing.date);
            return viewingDate && viewingDate >= now && viewingDate <= sevenDaysFromNow;
        });
        const counts = viewingsInNext7Days.reduce((acc, viewing) => {
            acc[viewing.status] = (acc[viewing.status] || 0) + 1;
            return acc;
        }, {});
        const chartData = Object.entries(counts).map(([status, count]) => {
            const meta = viewingStatusMeta[status];
            return {
                type: meta?.label || status,
                count,
                color: meta?.color || '#cccccc'
            };
        });
        container.innerHTML = '';
        if (!chartData.length) {
            container.innerHTML = '<p style="text-align:center; color: var(--muted-color); padding: 20px 0;">Nicio vizionare în următoarele 7 zile.</p>';
            return;
        }
        const chartContainer = document.createElement('div');
        chartContainer.className = 'pie-chart-container';
        const svgNs = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(svgNs, 'svg');
        svg.setAttribute('viewBox', '0 0 36 36');
        svg.classList.add('pie-chart-svg');
        const legendContainer = document.createElement('div');
        legendContainer.className = 'pie-chart-legend';
        const total = chartData.reduce((sum, item) => sum + item.count, 0);
        let accumulatedPercentage = 0;
        chartData.forEach(item => {
            const percentage = (item.count / total) * 100;
            const slice = document.createElementNS(svgNs, 'circle');
            slice.classList.add('pie-slice');
            slice.setAttribute('cx', '18');
            slice.setAttribute('cy', '18');
            slice.setAttribute('r', '15.9154943092');
            slice.setAttribute('fill', 'transparent');
            slice.setAttribute('stroke', item.color);
            slice.setAttribute('stroke-width', '3.8');
            slice.setAttribute('stroke-dasharray', `${percentage} ${100 - percentage}`);
            slice.setAttribute('stroke-dashoffset', `-${accumulatedPercentage}`);
            const title = document.createElementNS(svgNs, 'title');
            title.textContent = `${item.type}: ${item.count} (${percentage.toFixed(1)}%)`;
            slice.appendChild(title);
            svg.appendChild(slice);

            const legendItem = document.createElement('div');
            legendItem.className = 'legend-item';
            const dot = document.createElement('div');
            dot.className = 'legend-dot';
            dot.style.backgroundColor = item.color;
            const label = document.createElement('span');
            label.textContent = `${item.type} (${item.count})`;
            legendItem.append(dot, label);
            legendContainer.appendChild(legendItem);

            legendItem.addEventListener('mouseenter', () => slice.style.transform = 'scale(1.05)');
            legendItem.addEventListener('mouseleave', () => slice.style.transform = 'scale(1)');
            slice.addEventListener('mouseenter', () => legendItem.style.fontWeight = '600');
            slice.addEventListener('mouseleave', () => legendItem.style.fontWeight = 'normal');

            accumulatedPercentage += percentage;
        });
        chartContainer.appendChild(svg);
        chartContainer.appendChild(legendContainer);
        container.appendChild(chartContainer);
    }

    function renderVenueCards() {
        const container = document.getElementById('venue-cards');
        if (!container) {
            return;
        }
        container.innerHTML = '';
        venues.forEach(venue => {
            const card = document.createElement('article');
            card.className = 'venue-card';

            const image = document.createElement('div');
            image.className = 'venue-card-image';
            if (venue.image) {
                image.style.backgroundImage = `url('${venue.image}')`;
            }

            const content = document.createElement('div');
            content.className = 'venue-card-content';

            const header = document.createElement('div');
            header.className = 'venue-card-header';

            const titleWrapper = document.createElement('div');
            const title = document.createElement('h3');
            title.textContent = venue.name;
            const location = document.createElement('p');
            location.className = 'venue-card-location';
            location.textContent = `${venue.city}, România`;
            titleWrapper.append(title, location);

            const statusKey = venue.status === 'activ' ? 'confirmed' : 'availability_confirmed';
            const statusChip = createStatusChip(statusKey);
            statusChip.textContent = venue.status;
            statusChip.dataset.status = statusKey;

            header.append(titleWrapper, statusChip);

            const meta = document.createElement('div');
            meta.className = 'venue-card-meta';
            const capacityItem = document.createElement('span');
            capacityItem.className = 'venue-meta-item';
            capacityItem.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg><span>Capacitate: ' + venue.capacity + '</span>';
            meta.appendChild(capacityItem);

            const footer = document.createElement('div');
            footer.className = 'venue-card-footer';
            if (typeof venue.price === 'number') {
                const price = document.createElement('span');
                price.className = 'venue-card-price';
                price.innerHTML = `de la <strong>${venue.price}€</strong>/pers`;
                footer.appendChild(price);
            }
            const actions = document.createElement('div');
            actions.className = 'venue-card-actions';
            const editBtn = document.createElement('button');
            editBtn.type = 'button';
            editBtn.className = 'crm-button ghost';
            editBtn.textContent = 'Editează detalii';
            const availabilityBtn = document.createElement('button');
            availabilityBtn.type = 'button';
            availabilityBtn.className = 'crm-button primary';
            availabilityBtn.textContent = 'Actualizează disponibilitate';
            actions.append(editBtn, availabilityBtn);
            footer.appendChild(actions);

            content.append(header, meta, footer);
            card.append(image, content);
            container.appendChild(card);
        });
    }

    function setupBookingModal() {
        const modal = document.getElementById('add-booking-modal');
        const openButtons = Array.from(document.querySelectorAll('[data-open-booking-modal]'));
        const closeBtns = modal?.querySelectorAll('.modal-close-btn') || [];
        const form = document.getElementById('add-booking-form');
        const venueSelect = document.getElementById('booking-venue');
        if (!modal || openButtons.length === 0 || !form || !venueSelect) {
            return;
        }
        modal.classList.remove('is-visible');
        populateSelect(venueSelect, Array.from(venuesSelect).sort(), false);
        if (typeof flatpickr === 'function') {
            const dateInput = document.getElementById('booking-date');
            flatpickr(dateInput, { dateFormat: 'Y-m-d', altInput: true, altFormat: 'd M Y', locale: 'ro' });
        }
        const openModal = () => modal.classList.add('is-visible');
        const closeModal = () => modal.classList.remove('is-visible');
        openButtons.forEach(btn => btn.addEventListener('click', openModal));
        closeBtns.forEach(btn => btn.addEventListener('click', closeModal));
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeModal();
            }
        });

        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const formData = new FormData(form);
            const dateValue = formData.get('date');
            if (!dateValue) {
                window.alert('Te rugăm să selectezi o dată.');
                return;
            }
            const dateObject = new Date(dateValue);
            const guestsValue = parseInt(formData.get('guests'), 10);
            if (!Number.isFinite(guestsValue) || guestsValue < 1) {
                window.alert('Numărul de invitați este obligatoriu și trebuie să fie mai mare decât zero.');
                return;
            }
            const nextId = bookings.reduce((max, booking) => Math.max(max, booking.id), 0) + 1;
            const newBooking = {
                id: nextId,
                client: formData.get('client'),
                event: formData.get('event'),
                venue: formData.get('venue'),
                date: formatDate(dateObject),
                guests: guestsValue,
                status: 'confirmed',
                autoGenerated: false,
                email: formData.get('email'),
                phone: formData.get('phone'),
                details: formData.get('details')
            };
            bookings.push(newBooking);
            renderBookingsTable();
            renderOverviewLists();
            renderMonthlyCalendar();
            form.reset();
            closeModal();
            highlightBookingRow(newBooking.id, { scroll: true });
        });
    }

    function setupEditModal() {
        const modal = document.getElementById('view-booking-modal');
        const form = document.getElementById('edit-booking-form');
        if (!modal || !form) {
            return;
        }
        const closeBtns = modal.querySelectorAll('.modal-close-btn');
        const closeModal = () => modal.classList.remove('is-visible');
        closeBtns.forEach(btn => btn.addEventListener('click', closeModal));
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeModal();
            }
        });
        form.addEventListener('submit', (e) => {
            e.preventDefault();
            const bookingId = parseInt(document.getElementById('edit-booking-id').value, 10);
            const bookingIndex = bookings.findIndex(b => b.id === bookingId);
            if (bookingIndex === -1) {
                closeModal();
                return;
            }
            const formData = new FormData(form);
            const guestsValue = parseInt(formData.get('guests'), 10);
            if (!Number.isFinite(guestsValue) || guestsValue < 1) {
                window.alert('Numărul de invitați este obligatoriu și trebuie să fie mai mare decât zero.');
                return;
            }
            bookings[bookingIndex].client = formData.get('client');
            bookings[bookingIndex].email = formData.get('email');
            bookings[bookingIndex].phone = formData.get('phone');
            bookings[bookingIndex].event = formData.get('event');
            bookings[bookingIndex].venue = formData.get('venue');
            bookings[bookingIndex].guests = guestsValue;
            bookings[bookingIndex].details = formData.get('details');
            renderBookingsTable();
            renderOverviewLists();
            highlightBookingRow(bookingId);
            closeModal();
        });
    }

    function openEditBookingModal(booking) {
        const modal = document.getElementById('view-booking-modal');
        if (!modal) {
            return;
        }
        document.getElementById('edit-booking-id').value = booking.id;
        document.getElementById('edit-booking-client').value = booking.client || '';
        document.getElementById('edit-booking-email').value = booking.email || '';
        document.getElementById('edit-booking-phone').value = booking.phone || '';
        document.getElementById('edit-booking-guests').value = booking.guests || '';
        document.getElementById('edit-booking-details').value = booking.details || '';
        const eventTypeSelect = document.getElementById('edit-booking-event-type');
        eventTypeSelect.innerHTML = document.getElementById('booking-event-type').innerHTML;
        eventTypeSelect.value = booking.event;
        const venueSelect = document.getElementById('edit-booking-venue');
        venueSelect.innerHTML = document.getElementById('booking-venue').innerHTML;
        venueSelect.value = booking.venue;
        modal.classList.add('is-visible');
    }

    function navigateToBooking(bookingId) {
        activatePage('bookings');
        setTimeout(() => {
            highlightBookingRow(bookingId, { scroll: true });
        }, 100);
    }

    function navigateToViewing(viewingId) {
        activatePage('viewings');
        setTimeout(() => {
            highlightViewingRow(viewingId, { scroll: true });
        }, 100);
    }

    function initializeDynamicContent() {
        const availabilityWeekEl = document.getElementById('availability-week-range');
        if (availabilityWeekEl) {
            availabilityWeekEl.textContent = `Intervale pentru ${formatDate(today)} - ${formatDate(addDays(6))}`;
        }
    }

    initializeDynamicContent();
    renderOverviewLists();
    renderBookingsTable();
    renderViewingsTable();
    renderMonthlyCalendar();
    renderViewingsCalendar();
    setupBookingModal();
    setupEditModal();
    renderVenueCards();
    renderMonthlyOccupancyChart();
    renderEventTypeDistributionChart();
    renderViewingsStatusChart();

    document.getElementById('bookings-venue-filter')?.addEventListener('change', renderBookingsTable);
    document.getElementById('bookings-status-filter')?.addEventListener('change', renderBookingsTable);
    document.getElementById('bookings-client-filter')?.addEventListener('input', () => {
        renderBookingsTable();
    });
    document.getElementById('viewings-venue-filter')?.addEventListener('change', renderViewingsTable);
    document.getElementById('viewings-calendar-venue-filter')?.addEventListener('change', renderViewingsCalendar);

    document.getElementById('prev-viewings-month-btn')?.addEventListener('click', () => {
        currentViewingsMonthOffset -= 1;
        renderViewingsCalendar();
    });
    document.getElementById('next-viewings-month-btn')?.addEventListener('click', () => {
        currentViewingsMonthOffset += 1;
        renderViewingsCalendar();
    });
    document.getElementById('today-availability-btn')?.addEventListener('click', () => {
        currentMonthOffset = 0;
        renderMonthlyCalendar();
    });

    const monthYearPickerEl = document.getElementById('availability-month-year');
    if (monthYearPickerEl && typeof flatpickr === 'function' && typeof monthSelectPlugin === 'function') {
        flatpickr(monthYearPickerEl, {
            plugins: [
                new monthSelectPlugin({
                    shorthand: true,
                    dateFormat: 'F Y',
                    altFormat: 'F Y'
                })
            ],
            onChange(selectedDates) {
                const selectedDate = selectedDates[0];
                if (!selectedDate) {
                    return;
                }
                const base = new Date();
                const diff = (selectedDate.getFullYear() - base.getFullYear()) * 12 + (selectedDate.getMonth() - base.getMonth());
                currentMonthOffset = diff;
                renderMonthlyCalendar();
            }
        });
    }

    document.getElementById('prev-month-btn')?.addEventListener('click', () => {
        currentMonthOffset -= 1;
        renderMonthlyCalendar();
    });
    document.getElementById('next-month-btn')?.addEventListener('click', () => {
        currentMonthOffset += 1;
        renderMonthlyCalendar();
    });

    const bookingsTableBody = document.getElementById('bookings-table-body');
    bookingsTableBody?.addEventListener('click', (event) => {
        const actionBtn = event.target.closest('button[data-action]');
        if (!actionBtn) {
            return;
        }
        const row = actionBtn.closest('tr');
        if (!row) {
            return;
        }
        const bookingId = Number(row.dataset.identifier);
        if (!bookingId) {
            return;
        }
        handleBookingAction(bookingId, actionBtn.dataset.action);
    });

    const autoOfferToggle = document.getElementById('auto-offer-toggle');
    if (autoOfferToggle) {
        autoOfferEnabled = autoOfferToggle.checked;
        autoOfferToggle.addEventListener('change', (event) => {
            autoOfferEnabled = event.target.checked;
            const message = autoOfferEnabled
                ? 'Trimiterea automată de ofertă este activă. Confirmările vor trimite instant oferta standard.'
                : 'Trimiterea automată de ofertă este dezactivată. Clientul va primi doar confirmarea disponibilității.';
            showAutomationToast(message);
        });
    }

    function handleViewingAction(viewingId, action) {
        const viewing = viewings.find(item => item.id === viewingId);
        if (!viewing) {
            return;
        }
        if (action === 'confirm') {
            viewing.status = 'confirmed';
            viewing.notes = viewing.notes || '';
            showAutomationToast(`Prezența a fost confirmată pentru ${viewing.client}.`);
        } else if (action === 'reschedule') {
            viewing.status = 'viewing_rescheduled';
            showAutomationToast(`Propune o nouă dată pentru ${viewing.client}.`);
        }
        renderViewingsTable();
        renderViewingsStatusChart();
        renderViewingsCalendar();
        renderOverviewLists();
        selectedViewingId = viewingId;
        highlightViewingRow(viewingId, { scroll: true });
    }

    recordDetailBackBtn?.addEventListener('click', () => returnToListPage({ scroll: true }));
    recordDetailSaveBtn?.addEventListener('click', saveRecordDetailNote);
});
